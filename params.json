{"name":"ActiveInteraction","tagline":"Manage application specific business logic.","body":"[![Gem Version][]][1]\r\n[![Build Status][]][2]\r\n[![Coverage Status][]][3]\r\n[![Code Climate][]][4]\r\n[![Dependency Status][]][5]\r\n\r\nAt first it seemed alright. A little business logic in a controller\r\nor model wasn't going to hurt anything. Then one day you wake up\r\nand you're surrounded by fat models and unwieldy controllers. Curled\r\nup and crying in the corner, you can't help but wonder how it came\r\nto this.\r\n\r\nTake back control. Slim down models and wrangle monstrous controller\r\nmethods with ActiveInteraction.\r\n\r\nCheck out the full [documentation][] on RubyDoc.info.\r\n\r\n## Installation\r\n\r\nThis project uses [semantic versioning][].\r\n\r\nAdd it to your Gemfile:\r\n\r\n```ruby\r\ngem 'active_interaction', '~> 0.5.0'\r\n```\r\n\r\nAnd then execute:\r\n\r\n```sh\r\n$ bundle\r\n```\r\n\r\nOr install it yourself with:\r\n\r\n```sh\r\n$ gem install active_interaction\r\n```\r\n\r\n## What do I get?\r\n\r\nActiveInteraction::Base lets you create interaction models. These\r\nmodels ensure that certain options are provided and that those\r\noptions are in the format you want them in. If the options are valid\r\nit will call `execute`, store the return value of that method in\r\n`result`, and return an instance of your ActiveInteraction::Base\r\nsubclass. Let's looks at a simple example:\r\n\r\n```ruby\r\n# Define an interaction that signs up a user.\r\nclass UserSignup < ActiveInteraction::Base\r\n  # required\r\n  string :email, :name\r\n\r\n  # optional\r\n  boolean :newsletter_subscribe, allow_nil: true\r\n\r\n  # ActiveRecord validations\r\n  validates :email, format: EMAIL_REGEX\r\n\r\n  # The execute method is called only if the options validate. It\r\n  # does your business action. The return value will be stored in\r\n  # `result`.\r\n  def execute\r\n    user = User.create!(email: email, name: name)\r\n    if newsletter_subscribe\r\n      NewsletterSubscriptions.create(email: email, user_id: user.id)\r\n    end\r\n    UserMailer.async(:deliver_welcome, user.id)\r\n    user\r\n  end\r\nend\r\n\r\n# In a controller action (for instance), you can run it:\r\ndef new\r\n  @signup = UserSignup.new\r\nend\r\n\r\ndef create\r\n  @signup = UserSignup.run(params[:user])\r\n\r\n  # Then check to see if it worked:\r\n  if @signup.valid?\r\n    redirect_to welcome_path(user_id: signup.result.id)\r\n  else\r\n    render action: :new\r\n  end\r\nend\r\n```\r\n\r\nYou may have noticed that ActiveInteraction::Base quacks like\r\nActiveRecord::Base. It can use validations from your Rails application\r\nand check option validity with `valid?`. Any errors are added to\r\n`errors` which works exactly like an ActiveRecord model. Additionally,\r\neverything within the `execute` method is run in a transaction if\r\nActiveRecord is available.\r\n\r\n## How do I call an interaction?\r\n\r\nThere are two way to call an interaction. Given UserSignup, you can\r\ndo this:\r\n\r\n```ruby\r\noutcome = UserSignup.run(params)\r\nif outcome.valid?\r\n  # Do something with outcome.result...\r\nelse\r\n  # Do something with outcome.errors...\r\nend\r\n```\r\n\r\nOr, you can do this:\r\n\r\n```ruby\r\nresult = UserSignup.run!(params)\r\n# Either returns the result of execute,\r\n# or raises ActiveInteraction::InteractionInvalid\r\n```\r\n\r\n## What can I pass to an interaction?\r\n\r\nInteractions only accept a Hash for `run` and `run!`.\r\n\r\n```ruby\r\n# A user comments on an article\r\nclass CreateComment < ActiveInteraction::Base\r\n  model :article, :user\r\n  string :comment\r\n\r\n  validates :comment, length: { maximum: 500 }\r\n\r\n  def execute; ...; end\r\nend\r\n\r\ndef somewhere\r\n  outcome = CreateComment.run(\r\n    comment: params[:comment],\r\n    article: Article.find(params[:article_id]),\r\n    user: current_user\r\n  )\r\nend\r\n```\r\n\r\n## How do I define an interaction?\r\n\r\n1. Subclass ActiveInteraction::Base\r\n\r\n    ```ruby\r\n    class YourInteraction < ActiveInteraction::Base\r\n      # ...\r\n    end\r\n    ```\r\n\r\n2. Define your attributes:\r\n\r\n    ```ruby\r\n    string :name, :state\r\n    integer :age\r\n    boolean :is_special\r\n    model :account\r\n    array :tags, allow_nil: true do\r\n      string\r\n    end\r\n    hash :prefs, allow_nil: true do\r\n      boolean :smoking\r\n      boolean :view\r\n    end\r\n    date :arrives_on, default: Date.today\r\n    date :departs_on, default: Date.tomorrow\r\n    ```\r\n\r\n3. Use any additional validations you need:\r\n\r\n    ```ruby\r\n    validates :name, length: { maximum: 10 }\r\n    validates :state, inclusion: { in: %w(AL AK AR ... WY) }\r\n    validate :arrives_before_departs\r\n\r\n    private\r\n\r\n    def arrive_before_departs\r\n      if departs_on <= arrives_on\r\n        errors.add(:departs_on, 'must come after the arrival time')\r\n      end\r\n    end\r\n    ```\r\n\r\n4. Define your execute method. It can return whatever you like:\r\n\r\n    ```ruby\r\n    def execute\r\n      record = do_thing(...)\r\n      # ...\r\n      record\r\n    end\r\n    ```\r\n\r\nCheck out the [documentation][] for a full list of methods.\r\n\r\n## How do I translate an interaction?\r\n\r\nActiveInteraction is i18n-aware out of the box! All you have to do\r\nis add translations to your project. In Rails, they typically go\r\ninto `config/locales`. So, for example, let's say that (for whatever\r\nreason) you want to print out everything backwards. Simply add\r\ntranslations for ActiveInteraction to your `hsilgne` locale:\r\n\r\n```yaml\r\n# config/locales/hsilgne.yml\r\nhsilgne:\r\n  active_interaction:\r\n    types:\r\n      array: yarra\r\n      boolean: naeloob\r\n      date: etad\r\n      date_time: emit etad\r\n      file: elif\r\n      float: taolf\r\n      hash: hsah\r\n      integer: regetni\r\n      model: ledom\r\n      string: gnirts\r\n      time: emit\r\n    errors:\r\n      messages:\r\n        invalid: dilavni si\r\n        invalid_nested: '%{type} dilav a ton si'\r\n        missing: deriuqer si\r\n```\r\n\r\nThen set your locale and run an interaction like normal:\r\n\r\n```ruby\r\nI18n.locale = :hsilgne\r\nclass Interaction < ActiveInteraction::Base\r\n  boolean :a\r\n  def execute; end\r\nend\r\np Interaction.run.errors.messages\r\n# => {:a=>[\"deriuqer si\"]}\r\n```\r\n\r\n## Credits\r\n\r\nThis project was inspired by the fantastic work done in [Mutations][].\r\n\r\n  [1]: https://badge.fury.io/rb/active_interaction \"Gem Version\"\r\n  [2]: https://travis-ci.org/orgsync/active_interaction \"Build Status\"\r\n  [3]: https://coveralls.io/r/orgsync/active_interaction \"Coverage Status\"\r\n  [4]: https://codeclimate.com/github/orgsync/active_interaction \"Code Climate\"\r\n  [5]: https://gemnasium.com/orgsync/active_interaction \"Dependency Status\"\r\n  [build status]: https://travis-ci.org/orgsync/active_interaction.png\r\n  [code climate]: https://codeclimate.com/github/orgsync/active_interaction.png\r\n  [coverage status]: https://coveralls.io/repos/orgsync/active_interaction/badge.png\r\n  [dependency status]: https://gemnasium.com/orgsync/active_interaction.png\r\n  [documentation]: http://rubydoc.info/github/orgsync/active_interaction\r\n  [gem version]: https://badge.fury.io/rb/active_interaction.png\r\n  [mutations]: https://github.com/cypriss/mutations\r\n  [semantic versioning]: http://semver.org\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}