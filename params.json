{"name":"ActiveInteraction","tagline":"Manage application specific business logic.","body":"[![Gem Version][]][1]\r\n[![Build Status][]][2]\r\n[![Coverage Status][]][3]\r\n[![Code Climate][]][4]\r\n[![Dependency Status][]][5]\r\n\r\nAt first it seemed alright. A little business logic in a controller\r\nor model wasn't going to hurt anything. Then one day you wake up\r\nand you're surrounded by fat models and unwieldy controllers. Curled\r\nup and crying in the corner, you can't help but wonder how it came\r\nto this.\r\n\r\nTake back control. Slim down models and wrangle monstrous controller\r\nmethods with ActiveInteraction.\r\n\r\nRead more on the [project page][] or check out the full [documentation][]\r\non RubyDoc.info.\r\n\r\n## Installation\r\n\r\nThis project uses [semantic versioning][].\r\n\r\nAdd it to your Gemfile:\r\n\r\n```ruby\r\ngem 'active_interaction', '~> 0.10.1'\r\n```\r\n\r\nAnd then execute:\r\n\r\n```sh\r\n$ bundle\r\n```\r\n\r\nOr install it yourself with:\r\n\r\n```sh\r\n$ gem install active_interaction\r\n```\r\n\r\n## What do I get?\r\n\r\nActiveInteraction::Base lets you create interaction models. These\r\nmodels ensure that certain inputs are provided and that those\r\ninputs are in the format you want them in. If the inputs are valid\r\nit will call `execute`, store the return value of that method in\r\n`result`, and return an instance of your ActiveInteraction::Base\r\nsubclass. Let's look at a simple example:\r\n\r\n```ruby\r\n# Define an interaction that signs up a user.\r\nclass UserSignup < ActiveInteraction::Base\r\n  # required\r\n  string :email, :name\r\n\r\n  # optional\r\n  boolean :newsletter_subscribe, default: nil\r\n\r\n  # ActiveRecord validations\r\n  validates :email, format: EMAIL_REGEX\r\n\r\n  # The execute method is called only if the inputs validate. It\r\n  # does your business action. The return value will be stored in\r\n  # `result`.\r\n  def execute\r\n    user = User.create!(email: email, name: name)\r\n    if newsletter_subscribe\r\n      NewsletterSubscriptions.create(email: email, user_id: user.id)\r\n    end\r\n    UserMailer.async(:deliver_welcome, user.id)\r\n    user\r\n  end\r\nend\r\n\r\n# In a controller action (for instance), you can run it:\r\ndef new\r\n  @signup = UserSignup.new\r\nend\r\n\r\ndef create\r\n  @signup = UserSignup.run(params[:user])\r\n\r\n  # Then check to see if it worked:\r\n  if @signup.valid?\r\n    redirect_to welcome_path(user_id: signup.result.id)\r\n  else\r\n    render action: :new\r\n  end\r\nend\r\n```\r\n\r\nYou may have noticed that ActiveInteraction::Base quacks like\r\nActiveRecord::Base. It can use validations from your Rails application\r\nand check option validity with `valid?`. Any errors are added to\r\n`errors` which works exactly like an ActiveRecord model. Additionally,\r\neverything within the `execute` method is run in a transaction if\r\nActiveRecord is available.\r\n\r\n## How do I call an interaction?\r\n\r\nThere are two way to call an interaction. Given UserSignup, you can\r\ndo this:\r\n\r\n```ruby\r\noutcome = UserSignup.run(params)\r\nif outcome.valid?\r\n  # Do something with outcome.result...\r\nelse\r\n  # Do something with outcome.errors...\r\nend\r\n```\r\n\r\nOr, you can do this:\r\n\r\n```ruby\r\nresult = UserSignup.run!(params)\r\n# Either returns the result of execute,\r\n# or raises ActiveInteraction::InvalidInteractionError\r\n```\r\n\r\n## What can I pass to an interaction?\r\n\r\nInteractions only accept a Hash for `run` and `run!`.\r\n\r\n```ruby\r\n# A user comments on an article\r\nclass CreateComment < ActiveInteraction::Base\r\n  model :article, :user\r\n  string :comment\r\n\r\n  validates :comment, length: { maximum: 500 }\r\n\r\n  def execute; ...; end\r\nend\r\n\r\ndef somewhere\r\n  outcome = CreateComment.run(\r\n    comment: params[:comment],\r\n    article: Article.find(params[:article_id]),\r\n    user: current_user\r\n  )\r\nend\r\n```\r\n\r\n## How do I define an interaction?\r\n\r\n1. Subclass ActiveInteraction::Base\r\n\r\n    ```ruby\r\n    class YourInteraction < ActiveInteraction::Base\r\n      # ...\r\n    end\r\n    ```\r\n\r\n2. Define your attributes:\r\n\r\n    ```ruby\r\n    string :name, :state\r\n    integer :age\r\n    boolean :is_special\r\n    model :account\r\n    array :tags, default: nil do\r\n      string\r\n    end\r\n    hash :prefs, default: nil do\r\n      boolean :smoking\r\n      boolean :view\r\n    end\r\n    date :arrives_on, default: Date.today\r\n    date :departs_on, default: Date.tomorrow\r\n    ```\r\n\r\n3. Use any additional validations you need:\r\n\r\n    ```ruby\r\n    validates :name, length: { maximum: 10 }\r\n    validates :state, inclusion: { in: %w(AL AK AR ... WY) }\r\n    validate :arrives_before_departs\r\n\r\n    private\r\n\r\n    def arrive_before_departs\r\n      if departs_on <= arrives_on\r\n        errors.add(:departs_on, 'must come after the arrival time')\r\n      end\r\n    end\r\n    ```\r\n\r\n4. Define your execute method. It can return whatever you like:\r\n\r\n    ```ruby\r\n    def execute\r\n      record = do_thing(...)\r\n      # ...\r\n      record\r\n    end\r\n    ```\r\n\r\nCheck out the [documentation][] for a full list of methods.\r\n\r\n## How do I compose interactions?\r\n\r\n(Note: this feature is experimental. See [#41][] & [#79][].)\r\n\r\nYou can run interactions from within other interactions by calling `compose`.\r\nIf the interaction is successful, it'll return the result (just like if you had\r\ncalled it with `run!`). If something went wrong, execution will halt\r\nimmediately and the errors will be moved onto the caller.\r\n\r\n```ruby\r\nclass DoSomeMath < ActiveInteraction::Base\r\n  integer :x, :y\r\n  def execute\r\n    sum = compose(Add, inputs)\r\n    square = compose(Square, x: sum)\r\n    compose(Add, x: square, y: square)\r\n  end\r\nend\r\nDoSomeMath.run!(x: 3, y: 5)\r\n# 128 => ((3 + 5) ** 2) * 2\r\n```\r\n\r\n```ruby\r\nclass AddThree < ActiveInteraction::Base\r\n  integer :y\r\n  def execute\r\n    compose(Add, x: 3, y: y)\r\n  end\r\nend\r\nAddThree.run!(y: nil)\r\n# => ActiveInteraction::InvalidInteractionError: Y is required\r\n```\r\n\r\n## How do I translate an interaction?\r\n\r\nActiveInteraction is i18n-aware out of the box! All you have to do\r\nis add translations to your project. In Rails, they typically go\r\ninto `config/locales`. So, for example, let's say that (for whatever\r\nreason) you want to print out everything backwards. Simply add\r\ntranslations for ActiveInteraction to your `hsilgne` locale:\r\n\r\n```yaml\r\n# config/locales/hsilgne.yml\r\nhsilgne:\r\n  active_interaction:\r\n    types:\r\n      array: yarra\r\n      boolean: naeloob\r\n      date: etad\r\n      date_time: emit etad\r\n      file: elif\r\n      float: taolf\r\n      hash: hsah\r\n      integer: regetni\r\n      model: ledom\r\n      string: gnirts\r\n      time: emit\r\n    errors:\r\n      messages:\r\n        invalid: dilavni si\r\n        invalid_nested: '%{type} dilav a ton si'\r\n        missing: deriuqer si\r\n```\r\n\r\nThen set your locale and run an interaction like normal:\r\n\r\n```ruby\r\nI18n.locale = :hsilgne\r\nclass Interaction < ActiveInteraction::Base\r\n  boolean :a\r\n  def execute; end\r\nend\r\np Interaction.run.errors.messages\r\n# => {:a=>[\"deriuqer si\"]}\r\n```\r\n\r\n## Credits\r\n\r\nActiveInteraction is brought to you by [@AaronLasseigne][] and\r\n[@tfausak][] from [@orgsync][]. We were inspired by the fantastic\r\nwork done in [Mutations][].\r\n\r\n  [#41]: https://github.com/orgsync/active_interaction/issues/41\r\n  [#79]: https://github.com/orgsync/active_interaction/issues/79\r\n  [1]: https://badge.fury.io/rb/active_interaction \"Gem Version\"\r\n  [2]: https://travis-ci.org/orgsync/active_interaction \"Build Status\"\r\n  [3]: https://coveralls.io/r/orgsync/active_interaction \"Coverage Status\"\r\n  [4]: https://codeclimate.com/github/orgsync/active_interaction \"Code Climate\"\r\n  [5]: https://gemnasium.com/orgsync/active_interaction \"Dependency Status\"\r\n  [@AaronLasseigne]: https://github.com/AaronLasseigne\r\n  [@orgsync]: https://github.com/orgsync\r\n  [@tfausak]: https://github.com/tfausak\r\n  [build status]: https://travis-ci.org/orgsync/active_interaction.png\r\n  [code climate]: https://codeclimate.com/github/orgsync/active_interaction.png\r\n  [coverage status]: https://coveralls.io/repos/orgsync/active_interaction/badge.png\r\n  [dependency status]: https://gemnasium.com/orgsync/active_interaction.png\r\n  [documentation]: http://rubydoc.info/github/orgsync/active_interaction\r\n  [gem version]: https://badge.fury.io/rb/active_interaction.png\r\n  [mutations]: https://github.com/cypriss/mutations\r\n  [project page]: http://orgsync.github.io/active_interaction/\r\n  [semantic versioning]: http://semver.org/spec/v2.0.0.html\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}